<template>
  <div
    class="epub-reader-container flex flex-col h-full w-full relative text-gray-800"
    :class="{ 'dark-mode': isDarkMode }"
  >
    <!-- Reader header with controls -->
    <header
      class="reader-header flex justify-between items-center p-2 border-b border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm"
    >
      <div class="flex items-center space-x-2">
        <router-link
          to="/library"
          class="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition"
        >
          <span class="text-lg">üîô</span> Back to Library
        </router-link>
        <h1 class="font-semibold text-gray-800 dark:text-gray-200">
          {{ bookMetadata.title }}
        </h1>
      </div>

      <div class="flex items-center space-x-4">
        <!-- Font size controls -->
        <div class="text-controls flex items-center space-x-2">
          <button
            @click="decreaseFontSize"
            class="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition"
            title="Decrease font size"
          >
            <span class="text-lg">A-</span>
          </button>
          <button
            @click="increaseFontSize"
            class="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition"
            title="Increase font size"
          >
            <span class="text-lg">A+</span>
          </button>
        </div>

        <!-- Theme toggle -->
        <button
          @click="toggleTheme"
          class="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition"
          title="Toggle light/dark mode"
        >
          <span v-if="isDarkMode" class="text-lg">‚òÄÔ∏è</span>
          <span v-else class="text-lg">üåô</span>
        </button>

        <!-- Paragraph numbering toggle -->
        <button
          @click="toggleParagraphNumbering"
          class="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition"
          :class="{ 'bg-blue-100 dark:bg-blue-900': showParagraphNumbers }"
          title="Toggle paragraph numbering"
        >
          <span class="text-lg">¬∂</span>
        </button>

        <!-- Chapter navigation -->
        <div class="navigation-controls flex items-center space-x-2">
          <button
            @click="prevChapter"
            class="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition"
            :disabled="currentChapterIndex <= 0"
            title="Previous chapter"
          >
            <span class="text-lg">‚óÄÔ∏è</span>
          </button>
          <button
            @click="nextChapter"
            class="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition"
            :disabled="currentChapterIndex >= totalChapters - 1"
            title="Next chapter"
          >
            <span class="text-lg">‚ñ∂Ô∏è</span>
          </button>
        </div>
      </div>
    </header>

    <!-- Reader Content Area -->
    <main
      class="reader-content flex-grow relative bg-gray-50 dark:bg-gray-900 overflow-auto"
    >
      <!-- Loading spinner -->
      <div
        v-if="isLoading"
        class="absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75"
      >
        <div
          class="animate-spin rounded-full h-12 w-12 border-t-4 border-blue-500"
        ></div>
      </div>

      <!-- Error message -->
      <div
        v-else-if="errorMessage"
        class="absolute inset-0 flex flex-col items-center justify-center p-4 text-center bg-red-50 dark:bg-red-900 dark:bg-opacity-80"
      >
        <p class="text-red-600 dark:text-red-300 font-semibold mb-2">
          Error loading book:
        </p>
        <p class="text-red-500 dark:text-red-400 text-sm mb-4">
          {{ errorMessage }}
        </p>
        <button
          @click="loadBook"
          class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400"
        >
          Retry
        </button>
      </div>

      <!-- Bookmark context menu -->
      <div v-if="showBookmarkMenu" class="bookmark-menu fixed z-50 bg-white dark:bg-gray-800 shadow-lg rounded-md p-2 border border-gray-200 dark:border-gray-700" :style="{top: bookmarkMenuPosition.y + 'px', left: bookmarkMenuPosition.x + 'px'}">
        <button 
          @click="createBookmarkFromSelectedParagraph" 
          class="w-full text-left px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 rounded flex items-center">
          <span class="mr-2">üîñ</span> Add bookmark
        </button>
      </div>
      
      <!-- Book content -->
      <div
        v-else
        class="chapter-content-wrapper px-4 py-3 max-w-3xl mx-auto overflow-auto"
        ref="scrollContainer"
        @scroll="handleScroll"
        id="chapter-content-container"
      >
        <!-- Use v-html with sanitized content -->
        <div 
          v-html="currentChapterContent" 
          ref="contentEl"
          :style="contentStyle"
          @click="handleContentClick"
          class="chapter-content"
        ></div>
      </div>

      <!-- Page info display -->
      <div
        v-if="!isLoading && !errorMessage && currentChapterContent"
        class="page-info absolute bottom-2 right-2 p-2 bg-black bg-opacity-50 text-white text-xs rounded"
      >
        Chapter {{ currentChapterIndex + 1 }}/{{ totalChapters }} |
        {{ pageInfo }}
      </div>
    </main>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted, onUnmounted, nextTick } from "vue";
import { useStorage } from "@vueuse/core";
import EpubParser from "../utils/epubParser";
import { testEpubFile, createDownloadLink } from "../utils/epubTest";

// Props
const props = defineProps({
  bookId: {
    type: String,
    default: "alice",
  },
  bookTitle: {
    type: String,
    default: "Alice's Adventures in Wonderland",
  },
  bookUrl: {
    type: String,
    required: true,
  },
  theme: {
    type: String,
    default: "light",
  },
  fontSize: {
    type: Number,
    default: 16,
  },
});

// Emits
const emit = defineEmits([
  "progress-update",
  "book-loaded",
  "book-load-error",
  "font-size-change",
  "theme-toggle",
]);

// State
const epubParser = ref(null);
const currentChapterIndex = ref(0);
const currentChapterContent = ref('');
const totalChapters = ref(0);
const isLoading = ref(true);
const errorMessage = ref(null);
const contentEl = ref(null);
const scrollContainer = ref(null); // Reference to the scrollable container
const pageInfo = ref('');
const bookMetadata = ref({ title: '', creator: '', publisher: '' });
const isDarkMode = computed(() => props.theme === 'dark');
const showParagraphNumbers = ref(false);
const bookmarks = ref([]); // Store bookmarks for the current book

// Bookmark context menu state
const showBookmarkMenu = ref(false);
const bookmarkMenuPosition = ref({ x: 0, y: 0 });
const selectedParagraph = ref(null); // Currently selected paragraph for bookmarking

// Computed
const contentStyle = computed(() => ({
  "font-size": `${props.fontSize}px`,
  "line-height": "1.5",
  color: isDarkMode.value ? "#e0e0e0" : "#333",
  "background-color": isDarkMode.value ? "#1a1a1a" : "#fff",
  padding: "1rem",
  "min-height": "100%",
}));

// Reading position state
const epubLocation = ref({
  chapterIndex: 0,
  scrollPosition: 0,
});

// Function to save the reading position
const saveReadingPosition = () => {
  if (!props.bookId) return;
  
  try {
    // Save both chapter index and exact scroll position
    const positionData = {
      chapterIndex: epubLocation.value.chapterIndex,
      scrollPosition: epubLocation.value.scrollPosition,
      savedAt: new Date().toISOString()
    };
    
    localStorage.setItem(
      `book-progress-${props.bookId}`,
      JSON.stringify(positionData)
    );
    
    // Add detailed console log for saving
    const chapterIndex = positionData.chapterIndex + 1; // 1-based for display
    const scrollPos = Math.round(positionData.scrollPosition);
    console.log(`%cüì• SAVED POSITION: Chapter ${chapterIndex}, Scroll ${scrollPos}px at ${new Date().toLocaleTimeString()}`, 'color: #4CAF50; font-weight: bold');
    console.log('Saved position data:', positionData);
    
    // Also emit the progress update to parent component
    emit('progress-update', {
      progress: calculateProgress(),
      position: positionData
    });
  } catch (error) {
    console.error('Error saving reading position:', error);
  }
};

// Function to load the reading position
const loadReadingPosition = () => {
  if (!props.bookId) return false;
  
  try {
    console.log(`%cüîç ATTEMPTING TO LOAD POSITION for book ID: ${props.bookId}`, 'color: #2196F3; font-weight: bold');
    
    // Try multiple sources in order of reliability
    const sources = [
      { name: 'window object', data: window.lastSavedPosition },
      { name: 'sessionStorage', data: JSON.parse(sessionStorage.getItem(`book-progress-${props.bookId}`)) },
      { name: 'localStorage', data: JSON.parse(localStorage.getItem(`book-progress-${props.bookId}`)) }
    ];
    
    let savedData = null;
    let sourceName = '';
    
    // Find the first available source with valid data
    for (const source of sources) {
      try {
        if (source.data && typeof source.data.chapterIndex === 'number') {
          savedData = source.data;
          sourceName = source.name;
          console.log(`Found saved position in ${sourceName}:`, savedData);
          break;
        }
      } catch(e) {
        console.log(`Error checking ${source.name}:`, e);
      }
    }
    
    if (savedData) {
      console.log(`Found saved position data in ${sourceName}`);
      
      // Ensure we always have a valid position
      const scrollPosition = typeof savedData.scrollPosition === 'number' ? savedData.scrollPosition : 0;
      
      // Ignore very small positions - they're likely at the top of the chapter
      if (scrollPosition < 5) {
        console.warn('Found position is too small (< 5px), might be invalid. Original value:', scrollPosition);
      }
      
      // Always set the position data to ensure consistency
      epubLocation.value = {
        chapterIndex: savedData.chapterIndex,
        scrollPosition: scrollPosition
      };
      
      // Make sure it's saved in all storage mechanisms for future use
      try {
        const positionJson = JSON.stringify(epubLocation.value);
        localStorage.setItem(`book-progress-${props.bookId}`, positionJson);
        sessionStorage.setItem(`book-progress-${props.bookId}`, positionJson);
        window.lastSavedPosition = epubLocation.value;
      } catch (e) {
        console.error('Error synchronizing position across storage:', e);
      }
      
      // Add detailed console log for loading
      const chapterIndex = savedData.chapterIndex + 1; // 1-based for display
      const scrollPos = Math.round(savedData.scrollPosition);
      const savedTime = savedData.savedAt ? new Date(savedData.savedAt).toLocaleString() : 'unknown';
      
      console.log(`%cüì§ LOADED POSITION: Chapter ${chapterIndex}, Scroll ${scrollPos}px (saved at ${savedTime})`, 'color: #FF9800; font-weight: bold');
      console.log('Loaded position details:', savedData);
      
      return true;
    } else {
      console.warn('No valid saved position found in any storage mechanism');
    }
  } catch (error) {
    console.error('Error loading reading position:', error);
  }
  return false;
};

// Set up global scroll tracking to catch ALL scrolling events
const setupScrollTracking = () => {
  if (window.scrollHandlerAttached) return; // Avoid duplicate handlers
  
  console.log('%cüî• Setting up safe scroll tracking system', 'color: #4CAF50; font-weight: bold');
  
  // Create wrapper handlers that prevent errors
  const safeScrollHandler = (event) => {
    try {
      // Only handle if we have a valid event and target
      if (event && event.target) {
        handleGlobalScroll(event);
      }
    } catch (error) {
      console.error('Error in scroll handler:', error.message);
      // Store for debugging
      window.epubDebug = window.epubDebug || {};
      window.epubDebug.lastError = { type: 'scroll', error: error.message, time: new Date().toISOString() };
    }
  };
  
  // Find all potential scrollable elements
  const scrollableSelectors = [
    '#chapter-content-wrapper',
    '.chapter-content-wrapper',
    '#chapter-content-container',
    '.chapter-content-container',
    '.reader-content',
    '.chapter-content',
    '#reader',
    '.reader',
    'main'
  ];
  
  // Get all scrollable elements safely
  const scrollableElements = [];
  try {
    scrollableSelectors.forEach(selector => {
      try {
        const elements = document.querySelectorAll(selector);
        if (elements && elements.length > 0) {
          elements.forEach(el => scrollableElements.push(el));
        }
      } catch (e) { /* ignore errors */ }
    });
    
    // Add document and body as fallbacks
    scrollableElements.push(document.body);
  } catch (e) { 
    console.warn('Error finding scrollable elements:', e.message);
  }
  
  console.log('Found', scrollableElements.length, 'potential scroll containers');
  
  // Attach handlers to window and document (safely)
  try {
    window.addEventListener('scroll', safeScrollHandler, { passive: true });
    document.addEventListener('scroll', safeScrollHandler, { passive: true });
  } catch (e) {
    console.warn('Error attaching core scroll listeners:', e.message);
  }
  
  // Attach to each scrollable element we found
  scrollableElements.forEach(el => {
    try {
      if (el && el instanceof Element) {
        el.addEventListener('scroll', safeScrollHandler, { passive: true });
        
        // Create safe element identifier for logging
        const elTag = el.tagName?.toLowerCase() || 'unknown';
        const elId = el.id ? '#' + el.id : '';
        const elClass = el.className && typeof el.className === 'string' ? 
          '.' + el.className.split(' ')[0] : '';
          
        console.log(`Added scroll listener to: ${elTag}${elId}${elClass}`);
      }
    } catch (error) {
      // Silently ignore errors for individual elements
    }
  });
  
  // Also add touchmove and wheel event handlers
  try {
    document.addEventListener('touchmove', safeScrollHandler, { passive: true });
    document.addEventListener('wheel', () => {
      try {
        setTimeout(() => saveManualReadingPosition(), 100);
      } catch (e) { /* ignore errors */ }
    }, { passive: true });
  } catch (e) { /* ignore errors */ }

    // Update page info
    updatePageInfo();
      }
    }, 20000);
  }
};

// Global scroll handler that will catch any scrolling in the reader area
let lastScrollTop = 0; // Track previous scroll position to detect changes
let lastScrollSaveTime = 0; // Track when we last saved position

const handleGlobalScroll = (event) => {
  // Safety check for valid event
  if (!event) {
    return;
  }
  
  // Safety check for target - must be a DOM element
  const target = event.target;
  if (!target || !(target instanceof Element)) {
    return;
  }
  
  // Rate limit logs to once per second to prevent console flooding
  const now = Date.now();
  const shouldLog = !window.lastScrollLogTime || now - window.lastScrollLogTime > 1000;
  
  if (shouldLog) {
    try {
      const targetDesc = target.id ? 
        `#${target.id}` : 
        `${target.tagName.toLowerCase()}${target.className ? '.' + target.className.split(' ')[0] : ''}`;
      console.log(`%cüöÄ SCROLL from ${targetDesc}`, 'color: #E91E63');
    } catch (e) {
      console.log(`%cüöÄ SCROLL EVENT detected`, 'color: #E91E63');
    }
    window.lastScrollLogTime = now;
  }
  
  // Find the scrollable container with safety checks
  const findScrollableParent = (element) => {
    // Prevent infinite recursion with a maximum depth
    const MAX_RECURSION_DEPTH = 10;
    const findScrollableWithDepth = (el, depth = 0) => {
      // Safety checks
      if (!el || !(el instanceof Element) || depth > MAX_RECURSION_DEPTH) {
        return null;
      }
      
      try {
        // Check if this element is scrollable
        const style = window.getComputedStyle(el);
        const overflowY = style.getPropertyValue('overflow-y');
        const hasScroll = overflowY !== 'visible' && overflowY !== 'hidden';
        
        if (hasScroll && el.scrollHeight > el.clientHeight) {
          if (shouldLog) {
            console.log(`Found scrollable element: ${el.tagName.toLowerCase()}${el.id ? '#'+el.id : ''}`);
          }
          return el;
        }
        
        // Check parent if it exists and is an Element
        if (el.parentElement && el.parentElement instanceof Element) {
          return findScrollableWithDepth(el.parentElement, depth + 1);
        }
      } catch (error) {
        // Just return null on any error
        return null;
      }
      
      return null;
    };
    
    return findScrollableWithDepth(element);
  };
  
  // Use known good selectors to find scrollable containers
  const knownContainers = [
    document.querySelector('#chapter-content-wrapper'),
    document.querySelector('.chapter-content-wrapper'),
    document.querySelector('.reader-content'),
    document.querySelector('main'),
    document.getElementById('reader'),
    document.querySelector('.chapter-content-container')
  ].filter(Boolean);
  
  // First try to find via event target
  let scrollingElement = null;
  try {
    if (event.target && event.target instanceof Element) {
      scrollingElement = findScrollableParent(event.target);
    }
  } catch (error) {
    console.warn('Error finding scrollable element from event target:', error.message);
  }
  
  // Fall back to known containers if needed
  if (!scrollingElement) {
    scrollingElement = knownContainers.find(el => {
      try {
        return el.scrollHeight > el.clientHeight;
      } catch (e) {
        return false;
      }
    });
  }
  
  if (scrollingElement) {
    // Get current scroll position
    const scrollTop = scrollingElement.scrollTop;
    
    if (shouldLog) {
      console.log('Scroll position:', scrollTop, 'on element:', scrollingElement.tagName, scrollingElement.className);
    }
    
    // Only process if we have a valid scroll position and it has changed significantly
    if (typeof scrollTop === 'number' && Math.abs(scrollTop - lastScrollTop) > 5) {
      lastScrollTop = scrollTop; // Update last scroll position
      
      // Don't save very small scroll values (likely at beginning of chapter)
      if (scrollTop < 5) {
        if (shouldLog) console.log('Ignoring very small scroll position');
        return;
      }
      
      // Update our in-memory position first
      epubLocation.value = {
        chapterIndex: currentChapterIndex.value,
        scrollPosition: scrollTop
      };
      
      // Debounce the save to avoid too many writes
      if (window.scrollSaveTimeout) {
        clearTimeout(window.scrollSaveTimeout);
      }
      
      // Rate-limit saves to prevent excessive storage operations
      const now = Date.now();
      if (now - lastScrollSaveTime < 500) { // Minimum 500ms between saves
        return;
      }
      
      // Update last save time
      lastScrollSaveTime = now;
      
      // Clear any existing timeout
      if (window.scrollSaveTimeout) {
        clearTimeout(window.scrollSaveTimeout);
      }
      
      // Save after a short delay if scrolling stops
      window.scrollSaveTimeout = setTimeout(() => {
        // Check if the position value is valid (not too small)
        if (scrollTop < 10) {
          console.log(`%c‚ö†Ô∏è Ignoring very small scroll position: ${scrollTop}px`, 'color: orange');
          return;
        }
        
        console.log(`%cüíæ SAVING SCROLL POSITION: ${Math.round(scrollTop)}px in chapter ${currentChapterIndex.value + 1}`, 'color: #4CAF50; font-weight: bold; font-size: 14px; background: #e8f5e9; padding: 2px 5px; border-radius: 3px;');
        const saved = saveManualReadingPosition();
        if (saved) {
          // Test the saved value immediately to make sure it's correct
          try {
            const savedData = JSON.parse(localStorage.getItem(`book-progress-${props.bookId}`));
            console.log('%cüîí POSITION VERIFICATION:', 'color: #E91E63; font-weight: bold;');
            console.table({
              'Saved Position (px)': Math.round(savedData?.scrollPosition || 0),
              'Original Position (px)': Math.round(scrollTop),
              'Saved Chapter': savedData?.chapterIndex + 1,
              'Current Chapter': currentChapterIndex.value + 1,
              'Timestamp': new Date().toLocaleTimeString()
            });
            
            // Save for debugging
            window.lastVerifiedPosition = {
              saved: Math.round(savedData?.scrollPosition || 0),
              original: Math.round(scrollTop),
              time: new Date().toISOString()
            };
          } catch (err) {}
        }
      }, 300);
    }
  } else if (shouldLog) {
    console.warn('Could not find scrollable element');
  }
};

// Function to apply aggressive scroll position restoration
const applyAggressiveScrollPosition = () => {
  // Get all potential scroll containers
  const scrollContainers = [
    document.querySelector('#chapter-content-wrapper'),
    document.querySelector('.chapter-content-wrapper'),
    document.querySelector('#chapter-content-container'),
    document.querySelector('.chapter-content-container'),
    document.querySelector('.reader-content'),
    document.querySelector('main'),
    document.body
  ].filter(Boolean);
  
  // Force position on all containers
  scrollContainers.forEach(container => {
    if (container && typeof container.scrollTop !== 'undefined') {
      try {
        if (epubLocation.value && epubLocation.value.scrollPosition > 10) {
          container.scrollTop = epubLocation.value.scrollPosition;
          console.log(`Applied position ${Math.round(epubLocation.value.scrollPosition)}px to ${container.tagName.toLowerCase()}`);
        }
      } catch (e) {
        // Ignore errors
      }
    }
  });
};

// Set up an interval for aggressive position restoration
const setupScrollRestoration = () => {
  // Only restore if we have a valid position
  if (!epubLocation.value || epubLocation.value.scrollPosition < 10) return;
  
  console.log(`%cüî• SETTING UP AGGRESSIVE POSITION RESTORATION: ${Math.round(epubLocation.value.scrollPosition)}px`, 'color: #FF5722; font-weight: bold');
  
  // First apply immediately
  applyAggressiveScrollPosition();
  
  // Then set up a persistent interval
  if (window.forceScrollInterval) {
    clearInterval(window.forceScrollInterval);
  }
  
  // Apply position repeatedly
  window.forceScrollInterval = setInterval(() => {
    applyAggressiveScrollPosition();
  }, 200); // Apply every 200ms
  
  // Stop interval after 5 seconds
  setTimeout(() => {
    if (window.forceScrollInterval) {
      clearInterval(window.forceScrollInterval);
      window.forceScrollInterval = null;
      console.log('%c‚úÖ STOPPED POSITION RESTORATION INTERVAL', 'color: green; font-weight: bold');
    }
  }, 5000);
};
      
    };
    
    // Schedule the completion with a delay to allow initial rendering
    setTimeout(completeChapterLoading, 100);
    
    // Update progress
    updateProgress();
  } catch (error) {
    console.error("CustomEpubReader: Error loading chapter:", error);
    errorMessage.value = `Failed to load chapter: ${error.message}`;
    isLoading.value = false;
  }
};

// Event handlers for bookmark functionality
const handleContentClick = (event) => {
  // Close bookmark menu if it's open
  if (showBookmarkMenu.value) {
    showBookmarkMenu.value = false;
    return;
  }

  // Check if a paragraph was clicked (for adding bookmark icon)
  const target = event.target.closest('p');
  if (target && event.altKey) {
    // Alt+Click on a paragraph adds a bookmark immediately
    const bookmark = addBookmark(target);
    if (bookmark) {
      // Show a toast notification
      const toast = document.createElement('div');
      toast.className = 'bookmark-toast fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50';
      toast.innerHTML = `<span class="mr-2">üîñ</span> Bookmark added`;
      document.body.appendChild(toast);

      // Remove toast after 2 seconds
      setTimeout(() => {
        document.body.removeChild(toast);
      }, 2000);

      // Emit event to notify parent
      emit('bookmark-added', bookmark);
    }
  }
};

const handleParagraphRightClick = (event) => {
  // Find the closest paragraph to the right-click
  const paragraph = event.target.closest('p');
  if (!paragraph) return;

  // Store the paragraph and position
  selectedParagraph.value = paragraph;
  bookmarkMenuPosition.value = {
    x: event.clientX,
    y: event.clientY
  };

  // Show context menu
  showBookmarkMenu.value = true;
};

const createBookmarkFromSelectedParagraph = () => {
  if (!selectedParagraph.value) return;

  // Create the bookmark
  const bookmark = addBookmark(selectedParagraph.value);

  // Hide menu
  showBookmarkMenu.value = false;

  // Clear selection
  selectedParagraph.value = null;

  // Emit event to notify parent
  if (bookmark) {
    emit('bookmark-added', bookmark);
  }
};

// Close bookmark menu when clicking outside
onMounted(() => {
  // Set up event listeners
  document.addEventListener('click', (event) => {
    if (showBookmarkMenu.value && !event.target.closest('.bookmark-menu')) {
      showBookmarkMenu.value = false;
    }
  });

  // Set up scroll event listener to track position
    // Set up global scroll tracking that will capture any scrolling in the reader component
  console.log('%cüö® INITIAL SETUP: Preparing scroll detection', 'color: #E91E63; font-weight: bold');
  
  // Will be called after book is loaded, but we'll try now too just in case
  setupScrollTracking();

  // Save position when user leaves the page
  window.addEventListener('beforeunload', () => {
    console.log('%cüíæ SAVING POSITION BEFORE PAGE UNLOAD', 'color: #E91E63; font-weight: bold');
    saveReadingPosition();
  });
});

onUnmounted(() => {
  console.log('%cüîÑ UNMOUNTING: Cleaning up event listeners and timers', 'color: #9C27B0; font-weight: bold');
  
  // Clean up our manual scroll listeners
  console.log('%cüöÆ Removing manual scroll event listeners', 'color: #F44336');
  
  // Clean up ALL our manual event listeners
  if (window.scrollHandlerAttached) {
    console.log('%cüöÆ Removing ALL scroll event listeners', 'color: #F44336');
    
    // Remove from window and document
    window.removeEventListener('scroll', handleGlobalScroll, true);
    document.removeEventListener('scroll', handleGlobalScroll, true);
    document.body.removeEventListener('scroll', handleGlobalScroll, true);
    document.removeEventListener('wheel', handleGlobalScroll, true);
    
    // Remove from any elements we might have attached to
    document.querySelectorAll('.chapter-content-wrapper, .reader-content, main').forEach(el => {
      el.removeEventListener('scroll', handleGlobalScroll, true);
    });
    
    window.scrollHandlerAttached = false;
  }
  
  // Save the final position before unmounting
  if (props.bookId && epubLocation.value) {
    console.log('%cüíæ Saving final position before unmounting', 'color: #E91E63');
    saveReadingPosition();
  }
  
  // Remove beforeunload listener
  window.removeEventListener('beforeunload', saveReadingPosition);
  
  // Clear any pending timers
  if (window.scrollSaveTimeout) {
    clearTimeout(window.scrollSaveTimeout);
    window.scrollSaveTimeout = null;
  }
  
  // Clear any other custom timers or intervals we might have set
  if (window.positionCheckInterval) {
    clearInterval(window.positionCheckInterval);
    window.positionCheckInterval = null;
  }
});

// Process any images in the chapter - replace placeholders with actual images
const processImages = async () => {
  if (!contentEl.value || !epubParser.value) return;
  
  const imgElements = contentEl.value.querySelectorAll('img[data-epub-src]');
  
  if (imgElements.length > 0) {
    console.log(`Processing ${imgElements.length} images in chapter`);
    
    // Create an array of promises for all image loads
    const imageLoadPromises = [];
    
    imgElements.forEach((img) => {
      const imgSrc = img.getAttribute('data-epub-src');
      if (!imgSrc) return;
      
      // Create a promise for each image load
      const loadPromise = new Promise(async (resolve) => {
        try {
          const imageData = await epubParser.value.getResource(imgSrc);
          if (imageData) {
            img.src = imageData;
            console.log(`Loaded image: ${imgSrc}`);
            
            // Add an onload handler to resolve when the image is actually rendered
            img.onload = () => {
              console.log(`Image rendered: ${imgSrc}`);
              resolve();
            };
            
            // Also resolve if image fails to load after 2 seconds
            setTimeout(resolve, 2000);
          } else {
            resolve(); // Resolve even if no image data
          }
        } catch (error) {
          console.error(`Error loading image: ${error.message}`);
          resolve(); // Resolve even on error
        }
      });
      
      imageLoadPromises.push(loadPromise);
    });
    
    // Wait for all images to load, but with a timeout to prevent endless waiting
    await Promise.race([
      Promise.all(imageLoadPromises),
      new Promise(resolve => setTimeout(resolve, 3000)) // 3 second timeout
    ]);
    
    console.log('Image processing complete (or timed out)');
    return true;
  }
  
  return false; // No images to process
};

// Navigation functions
const nextChapter = async () => {
  if (currentChapterIndex.value < totalChapters.value - 1) {
    await loadChapter(currentChapterIndex.value + 1);
  }
};

const prevChapter = async () => {
  if (currentChapterIndex.value > 0) {
    await loadChapter(currentChapterIndex.value - 1);
  }
};

// Update page info (could add page number calculation in the future)
const updatePageInfo = () => {
  if (!epubParser.value) return;

  const currentChapter = currentChapterIndex.value + 1;
  const totalChapters = epubParser.value.spine.length;
  let tocLabel = "";

  // Try to find current chapter in TOC
  if (epubParser.value.toc.length > 0) {
    const findInToc = (items, href) => {
      for (const item of items) {
        if (
          item.href === epubParser.value.spine[currentChapterIndex.value].href
        ) {
          return item.label;
        }
        if (item.subitems && item.subitems.length > 0) {
          const found = findInToc(item.subitems, href);
          if (found) return found;
        }
      }
      return null;
    };

    tocLabel =
      findInToc(
        epubParser.value.toc,
        epubParser.value.spine[currentChapterIndex.value].href
      ) || "";
  }

  pageInfo.value = tocLabel
    ? `${tocLabel}`
    : `Chapter ${currentChapter}/${totalChapters}`;
};

// Calculate and emit reading progress
const updateProgress = () => {
  if (totalChapters.value === 0) return;

  // Calculate combined progress value
  const progress = calculateProgress();

  emit('progress-update', {
    progress: progress,
    currentChapter: currentChapterIndex.value + 1,
    totalChapters: totalChapters.value,
    position: epubLocation.value
  });
};

// Helper function to calculate reading progress percentage
const calculateProgress = () => {
  if (totalChapters.value === 0) return 0;

  // Basic progress calculation: current chapter position / total chapters
  const chapterProgress = currentChapterIndex.value / totalChapters.value;

  // Adjust for scroll position within chapter
  let scrollProgress = 0;
  if (scrollContainer.value) {
    const maxScroll = scrollContainer.value.scrollHeight - scrollContainer.value.clientHeight;
    scrollProgress = maxScroll > 0 ? scrollContainer.value.scrollTop / maxScroll : 0;
  }

  // Combined progress (80% chapter position + 20% scroll position within chapter)
  return chapterProgress * 0.8 + (scrollProgress * 0.2 / totalChapters.value);
};

// Handle scroll to save position - Original component method
const handleScroll = (event) => {
  // Ensure we only process this if the reader is loaded and not in loading state
  if (scrollContainer.value && !isLoading.value) {
    // Get the current scroll position from the scrollable container
    const scrollTop = scrollContainer.value.scrollTop;
    
    // Update the current location with scroll position
    epubLocation.value = {
      chapterIndex: currentChapterIndex.value,
      scrollPosition: scrollTop,
    };
    
    // Log that scroll is being tracked (limit to once per second to avoid console spam)
    if (!window.lastScrollLogTime || Date.now() - window.lastScrollLogTime > 1000) {
      console.log(`%cüìù SCROLL DETECTED at position ${Math.round(scrollTop)}px`, 'color: #607D8B; font-style: italic');
      window.lastScrollLogTime = Date.now();
    }
    
    // Debounce the storage operation to avoid excessive writes
    if (window.scrollSaveTimeout) {
      clearTimeout(window.scrollSaveTimeout);
    }
    
    // Set a timeout to save the position after scrolling stops
    window.scrollSaveTimeout = setTimeout(() => {
      // Verify that the scroll container is still valid before saving
      if (scrollContainer.value) {
        // Double check the final position (may have changed slightly)
        const finalPosition = scrollContainer.value.scrollTop;
        
        // Update with the final position
        epubLocation.value.scrollPosition = finalPosition;
        
        // Save position to localStorage after scroll stops
        console.log(`%cüíæ SAVING READING POSITION after scroll (final position: ${Math.round(finalPosition)}px)`, 'color: #E91E63; font-weight: bold');
        saveReadingPosition();
        
        // Update progress display
        updatePageInfo();
      }
    }, 300); // Save after 300ms of scroll inactivity
  }
};

// Font size controls
const increaseFontSize = () => {
  emit("font-size-change", props.fontSize + 1);
};

const decreaseFontSize = () => {
  if (props.fontSize > 12) {
    emit("font-size-change", props.fontSize - 1);
  }
};

// Theme toggle
const toggleTheme = () => {
  emit("theme-toggle");
};

// Paragraph numbering toggle
const toggleParagraphNumbering = async () => {
  showParagraphNumbers.value = !showParagraphNumbers.value;
  // Save preference to localStorage
  localStorage.setItem(
    `paragraph-numbers-${props.bookId}`,
    showParagraphNumbers.value
  );
  // Reload current chapter with new setting
  await loadChapter(currentChapterIndex.value);
};

// Get the table of contents from the parser
const getTableOfContents = () => {
  if (!epubParser.value || !epubParser.value.toc) {
    return [];
  }
  
  // Create a flattened array of all TOC items for easier display
  const flattenToc = (items, result = []) => {
    items.forEach(item => {
      // Add the current item
      result.push(item);
      
      // Process subitems if any
      if (item.subitems && item.subitems.length > 0) {
        flattenToc(item.subitems, result);
      }
    });
    
    return result;
  };
  
  return flattenToc(epubParser.value.toc);
};

// Navigate to a specific chapter by its href
const navigateToHref = async (href, anchor = null) => {
  if (!epubParser.value || !epubParser.value.spine) return;
  
  console.log(`CustomEpubReader: Navigating to href: ${href}, anchor: ${anchor}`);
  
  // Find the spine index that corresponds to the href
  const targetPath = href.replace(epubParser.value.rootfileDir, '').split('#')[0];
  const spineIndex = epubParser.value.spine.findIndex(item => {
    const itemPath = item.href.replace(epubParser.value.rootfileDir, '');
    return itemPath === targetPath || item.href === href;
  });
  
  if (spineIndex !== -1) {
    console.log(`CustomEpubReader: Found matching spine item at index ${spineIndex}`);
    
    // Load the chapter
    await loadChapter(spineIndex);
    
    // If there's an anchor, scroll to it
    if (anchor && contentEl.value) {
      setTimeout(() => {
        const anchorElement = contentEl.value.querySelector(`#${anchor}, [id='${anchor}']`);
        if (anchorElement) {
          anchorElement.scrollIntoView({ behavior: 'smooth' });
          console.log(`CustomEpubReader: Scrolled to anchor ${anchor}`);
        } else {
          console.warn(`CustomEpubReader: Anchor ${anchor} not found in chapter`);
        }
      }, 100); // Small delay to ensure the content is rendered
    }
  } else {
    console.warn(`CustomEpubReader: Could not find spine item for href ${href}`);
  }
};

// Bookmark-related methods
const loadBookmarks = () => {
  try {
    const storedBookmarks = localStorage.getItem(`bookmarks_${props.bookId}`);
    if (storedBookmarks) {
      bookmarks.value = JSON.parse(storedBookmarks);
      console.log(`Loaded ${bookmarks.value.length} bookmarks for book ${props.bookId}`);
    }
  } catch (error) {
    console.error('Error loading bookmarks:', error);
    bookmarks.value = [];
  }
};

const saveBookmarks = () => {
  try {
    localStorage.setItem(`bookmarks_${props.bookId}`, JSON.stringify(bookmarks.value));
    console.log(`Saved ${bookmarks.value.length} bookmarks for book ${props.bookId}`);
  } catch (error) {
    console.error('Error saving bookmarks:', error);
  }
};

const addBookmark = (paragraphEl) => {
  if (!paragraphEl || !contentEl.value) return null;
  
  // Get the paragraph text (limited to first 50 chars) for the bookmark title
  const paragraphText = paragraphEl.textContent.trim().substring(0, 50) + (paragraphEl.textContent.length > 50 ? '...' : '');
  
  // Create a unique ID for the paragraph
  const paragraphIndex = Array.from(contentEl.value.querySelectorAll('p')).indexOf(paragraphEl);
  
  // Create bookmark object
  const bookmark = {
    id: `bm-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
    chapterIndex: currentChapterIndex.value,
    chapterTitle: pageInfo.value,
    paragraphIndex: paragraphIndex,
    paragraphText: paragraphText,
    createdAt: new Date().toISOString(),
  };
  
  // Add to bookmarks array
  bookmarks.value.push(bookmark);
  
  // Save to localStorage
  saveBookmarks();
  
  console.log('Added bookmark:', bookmark);
  
  // Return the created bookmark
  return bookmark;
};

const removeBookmark = (bookmarkId) => {
  const index = bookmarks.value.findIndex(bm => bm.id === bookmarkId);
  if (index !== -1) {
    const removed = bookmarks.value.splice(index, 1)[0];
    saveBookmarks();
    console.log('Removed bookmark:', removed);
    return true;
  }
  return false;
};

const navigateToBookmark = async (bookmark) => {
  if (!bookmark || typeof bookmark.chapterIndex !== 'number') return false;
  
  // First navigate to the chapter
  if (currentChapterIndex.value !== bookmark.chapterIndex) {
    await loadChapter(bookmark.chapterIndex);
  }
  
  // Then scroll to the paragraph
  setTimeout(() => {
    if (contentEl.value && typeof bookmark.paragraphIndex === 'number') {
      const paragraphs = contentEl.value.querySelectorAll('p');
      if (paragraphs.length > bookmark.paragraphIndex) {
        const targetParagraph = paragraphs[bookmark.paragraphIndex];
        targetParagraph.scrollIntoView({ behavior: 'smooth' });
        
        // Briefly highlight the paragraph
        targetParagraph.classList.add('bookmark-highlight');
        setTimeout(() => {
          targetParagraph.classList.remove('bookmark-highlight');
        }, 2000);
        
        console.log(`Navigated to bookmark at paragraph ${bookmark.paragraphIndex}`);
        return true;
      }
    }
    return false;
  }, 100);
};

const getBookmarks = () => {
  return bookmarks.value;
};

// Expose methods to parent component
defineExpose({
  nextChapter,
  prevChapter,
  toggleParagraphNumbering,
  increaseFontSize,
  decreaseFontSize,
  toggleTheme,
  getTableOfContents,
  navigateToHref,
  addBookmark,
  removeBookmark,
  navigateToBookmark,
  getBookmarks
});

// Lifecycle hooks
onMounted(async () => {
  console.log("CustomEpubReader: Component mounted");
  
  // Load bookmarks for this book
  loadBookmarks();

  // Load paragraph numbering preference from localStorage
  const savedParagraphNumbering = localStorage.getItem(
    `paragraph-numbers-${props.bookId}`
  );
  if (savedParagraphNumbering !== null) {
    showParagraphNumbers.value = savedParagraphNumbering === "true";
  }

  await loadBook();

  // Add scroll listener
  if (contentEl.value) {
    contentEl.value.addEventListener("scroll", handleScroll);
  }

  // Force save reading position before page unload
  window.addEventListener('beforeunload', () => {
    if (contentEl.value && !isLoading.value) {
      // Update the position object with the latest scroll position
      epubLocation.value = {
        chapterIndex: currentChapterIndex.value,
        scrollPosition: contentEl.value.scrollTop,
      };
      
      // Force immediate save without debouncing
      localStorage.setItem(
        `book-progress-${props.bookId}`,
        JSON.stringify(epubLocation.value)
      );
      console.log('Force saved reading position before unload:', epubLocation.value);
    }
  });
});

onUnmounted(() => {
  // Save the current position before unmounting to ensure it's preserved
  saveReadingPosition();
  
  // Clean up resources
  if (epubParser.value) {
    epubParser.value.cleanup();
  }

  // Remove scroll listener
  if (contentEl.value) {
    contentEl.value.removeEventListener("scroll", handleScroll);
  }
});

// Watch for theme or font size changes
watch(
  () => props.theme,
  () => {
    // No need to do anything, the computed styles will update
  }
);

watch(
  () => props.fontSize,
  () => {
    // No need to do anything, the computed styles will update
  }
);
</script>

<style scoped>
/* Bookmark highlight effect */
.bookmark-highlight {
  animation: highlight-pulse 2s ease-in-out;
  background-color: rgba(255, 217, 0, 0.3);
  border-left: 3px solid gold;
  padding-left: 8px;
  margin-left: -11px;
}

@keyframes highlight-pulse {
  0% { background-color: rgba(255, 217, 0, 0); }
  50% { background-color: rgba(255, 217, 0, 0.3); }
  100% { background-color: rgba(255, 217, 0, 0.1); }
}

.dark-mode .bookmark-highlight {
  background-color: rgba(255, 217, 0, 0.2);
}

.epub-reader-container {
  height: 100%;
  width: 100%;
}

.reader-content {
  overflow-y: auto;
  position: relative;
}

.chapter-content {
  min-height: 100%;
}

.dark-mode {
  background-color: #1a1a1a;
  color: #e0e0e0;
}

/* Style buttons in dark mode */
.dark-mode button {
  color: #e0e0e0;
}

.dark-mode button:hover {
  background-color: #374151;
}
</style>

<style>
/* These styles apply to the HTML content from the EPUB */
.chapter-content img {
  max-width: 100%;
  height: auto;
  margin: 1rem auto;
  display: block;
}

.chapter-content h1,
.chapter-content h2,
.chapter-content h3,
.chapter-content h4,
.chapter-content h5,
.chapter-content h6 {
  font-weight: bold;
  margin-top: 1.5em;
  margin-bottom: 0.5em;
}

.chapter-content p {
  margin-bottom: 1em;
  color: inherit !important;
  text-decoration: none !important;
}

/* Override any text styling to use default text colors */
.chapter-content {
  color: inherit !important;
}

/* Apply to all elements */
.chapter-content * {
  color: inherit !important;
  text-decoration: none !important;
}

/* Make sure paragraphs never get underlined, even on hover */
.chapter-content p,
.chapter-content p:hover {
  color: inherit !important;
  text-decoration: none !important;
}

/* Only apply link styling to actual anchor links */
.chapter-content a,
.chapter-content a:hover {
  color: inherit !important;
  text-decoration: none !important;
}

/* Add a small color change on hover for actual links, but no underline */
.chapter-content a:hover {
  opacity: 0.8;
}

.dark-mode .chapter-content a:hover {
  opacity: 0.8;
}
</style>
